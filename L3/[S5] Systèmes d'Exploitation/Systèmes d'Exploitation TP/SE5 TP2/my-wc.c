#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <fcntl.h>
#include <string.h>
#include <getopt.h>
#include <stdio.h>

#define BUFFER_SIZE (1024*1024)

int do_wc(int in_fd, int out_fd, int write_newlines, int write_bytes, const char * in_filename);
int print_size(int fd, size_t size);

/* ./my-wc [-lc] [fichier] compte le nombre de retours à la ligne et/ou d'octets dans le
   fichier indiqué, ou à défaut sur l'entrée standard. */
int main(int argc, char * argv[]) {
  int result;
  char * in_filename = NULL;
  
  int write_newlines = 1; //0=ne pas faire, 1=faire
  int write_bytes = 1;
  
  int in_fd = STDIN_FILENO;

  int opt;
  while ((opt = getopt(argc, argv, "cl")) != -1) {
    /* TODO: Gérer les options -c et -l */
	switch(opt){
		case 'c':
			write_newlines=0;
			break;
		case 'l':
			write_bytes=0;
			break;
	}	
  }
  /* TODO: si ni -c ni -l n'a été donnée, faire en sorte d'afficher les deux */

  /* TODO: tester si un nom de fichier a été donné (cf. man getopt -> optind) et dans ce
     cas, le mettre dans in_filename */
  in_filename=argv[optind];

  /* TODO: si un nom de fichier autre que "-" a été donné, ouvrir le fichier correspondant */
  if(in_filename[0]!='-') in_fd=open(in_filename, O_RDONLY);

  /* TODO: appeler do_wc avec les bons arguments */
	result=do_wc(in_fd, STDOUT_FILENO, write_newlines, write_bytes, in_filename);

 //cleanup_return:
  /* TODO: fermer le fichier d'entrée. Ne pas oublier de tester s'il y a eu une erreur */
  close(in_fd);
  if(result==1) printf("erreur 52\n");
  return result;
}

/* Lit in_fd et compte le nombre de lignes et/ou d'octets lus. Affiche le résultat sur
   out_fd, suivi de in_filename si différent de NULL, le tout sous formes de colonnes
   séparées par une tabulation. Renvoie 0 en cas de succès et 1 en cas d'erreur. */
int do_wc(int in_fd, int out_fd, int write_newlines, int write_bytes, const char * in_filename) {
  int result;
  char * buffer = NULL;
  size_t lines=0;
  size_t bytes=0;

  /* TODO: allouer un buffer */
  buffer=malloc(BUFFER_SIZE);
  if(buffer==NULL){
	  result=1;
	  printf("erreur allocation memoire");
	  goto cleanup_return;
  }
  
  int r;
  while(1) {
    /* TODO: lire l'entrée et compter le nombre de retours à la ligne et d'octets */
	r=read(in_fd, buffer, size_of(char));
	if(r==-1){
		result=1;
		goto cleanup_return;
	}
	if(r==0){
		result=0;
		goto cleanup_return;
	}
	
	if(buffer[0]=='\n') lines++;
	else bytes++;
  }
  
  /* TODO: afficher ce qu'il faut */
  if(write_newlines==1) printf("%zu\t", lines);
  if(write_bytes==1) printf("%zu\t", bytes);
  write(out_fd, in_filename, BUFFER_SIZE);
  
  /* TODO: tout a fonctionné : mettre à jour result en conséquence */
  goto cleanup_return;
  
 cleanup_return:
  /* TODO: libérer le buffer */
  free(buffer);
  return result;
}

/* Renvoie le nombre d'octets écrits, ou -1 en cas d'erreur. */
/* TODO: Utiliser snprintf() avec le format %zu. */
/*int print_size(int fd, size_t size) {
  char * buffer=NULL;
  buffer=malloc(size);
  if(buffer==NULL){
	  printf("erreur allocation memoire");
	  return -1;
  }
  return snprintf(buffer, size, "%zu\n", fd);
}*/

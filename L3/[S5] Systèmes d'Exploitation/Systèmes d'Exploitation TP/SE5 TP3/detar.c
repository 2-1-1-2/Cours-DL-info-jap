#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include "tarutils.h"

#define MIN(a,b) (((a)<(b))?(a):(b))

char buf[BLOCKSIZE];
struct posix_header hd;

/* extraie de l'archive dont fd est un descripteur le fichier décrit par
 * l'entête phd : crée un fichier de nom phd -> name
 * et de contenu constitué des filesize octets suivants de l'archive.
 * Attention à respecter les droits phd -> mode */
int extract(int fd, struct posix_header * phd, unsigned int filesize) {

  /* TODO : vérification du type de fichier : seuls les REGTYPE et AREGTYPE
   * sont supportés */
  int typeflag=phd->typeflag;
  if(typeflag!= REGTYPE && typeflag!=AREGTYPE){
	  printf("pas le bon type de fichier\n");
	  return 1;
  }

  /* TODO : création du fichier avec les bons droits */
  mode_t filemode;
  sscanf(phd->mode, "%o", &filemode);
  int fd2=open(phd->name, O_CREAT|O_WRONLY, filemode);
  if(fd2==-1){
	  printf("fichier pas cree\n");
	  return 1;
  }

  /* TODO : recopie du contenu; ATTENTION au dernier bloc! */
  int r=read(fd, phd, filesize);//ajoute dans le buffer
  if(r!=filesize){
	  printf("erreur dans la lecture\n");
	  return 1;
  }
  int w=write(fd2, phd, filesize);//ecrit texte du buffer
  if(w!=filesize){
	  printf("erreur dans l ecriture\n");
	  return 1;
  }
  lseek(fd, -w, SEEK_CUR);//nombre d octets lus, donc recule pour avoir le fichier suivant

  /* TODO : refermer le descripteur */
  close(fd2);
  return 0;
}


int main(int argc, char **argv){
  int ret = 0, all;
  char * filename = NULL;
  struct posix_header * phd = &hd;

  switch (argc) {
    case 2 : all = 1; break;
    case 3 : all = 0; filename = argv[2]; break;
    default :
      fprintf(stderr, "Usage : %s file.tar [file]\n", argv[0]);
      exit(1);
  }

  /* TODO : ouverture du fichier tar */
  int fd=open(argv[1], O_RDONLY);
  if(fd<0){
	  perror("open");
	  exit(1);
  }

  unsigned int filesize, nblocks;
  int nb;

  /* boucle principale */
  while (1) {
    /* TODO : lecture de l'entête; vérifier que la lecture est bien complète */
    nb=read(fd, phd, BLOCKSIZE);
    if(nb!=BLOCKSIZE){
		printf("erreur lecture entete\n");
		ret=1;
		break;
    }

    /* TODO : la fin de l'archive est atteinte si le bloc est rempli de zéros,
     * et en particulier si name == "" */
    if(strcmp(phd->name, "")==0) break;

    /* vérification de checksum (facultatif) */
    if (!check_checksum(phd)) {
       fprintf(stderr, "Checksum erronée : %s\n", phd -> chksum);
       ret = 1;
       break;
    }

    /* TODO : la taille et le nombre de blocs sont toujours utiles */
    sscanf(phd->size, "%o", &filesize);
    nblocks=(filesize+BLOCKSIZE-1)/BLOCKSIZE;


    /* TODO[2] s'il s'agit d'une extraction complète (all == 1),
     * désarchiver le fichier et continuer (sauf en cas d'erreur)*/
	if(all==1){
		if((ret=extract(fd, phd, filesize))==1){
			printf("erreur extraction\n");
			break;
		}
	}

    /* TODO[1] s'il s'agit du fichier cherché, le désarchiver puis
     * quitter; sinon, sauter à l'entête suivant */
    else if(strcmp(phd->name, filename)==0){
		ret=extract(fd, phd, filesize);
		break;
    }
    lseek(fd, nblocks*BLOCKSIZE, SEEK_CUR);
  }

  /* TODO : fermeture du fichier tar */
  close(fd);
  
  exit(ret);
}

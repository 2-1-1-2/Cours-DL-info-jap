#define _POSIX_C_SOURCE 200809L
#define _DEFAULT_SOURCE
#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/stat.h>
#include <dirent.h>
#include <string.h>
#include <libgen.h>

struct stat stat_buffer;

/* Alloue un nouveau buffer avec malloc(), y stocke la concaténation des trois
 * chaînes passées en arguments, et renvoie un pointeur vers le nouveau
 * buffer. Renvoie NULL en cas d'échec de l'allocation. */
char * concat_strings(const char * str1, const char * str2, const char * str3) {
  /* TODO[1] : Allouer un buffer de la bonne taille, y stocker la concaténation
   * de str1, str2 et str3, et renvoyer un pointeur vers ce buffer */
   char * buffer;
   size_t size=strlen(str1)+strlen(str2)+strlen(str3);
   buffer=malloc(size);
   if(buffer==NULL){
	   printf("erreur malloc\n");
	   return NULL;
   }
   strncat(buffer, str1, strlen(str1));
   strncat(buffer, str2, strlen(str2));
   strncat(buffer, str3, strlen(str3));
   return buffer;
}

/*  parcourt récursivement le répertoire de référence path_name pour y
 *  chercher les fichiers de nom (de base) target_name;
 *  retourne le nombre de fichiers trouvés */
int process_dir(char * path, char * target_name) {
  DIR *dir;
  dir=opendir(path);
  if(dir==NULL){
	  printf("erreur opendir\n");
	  return -1;
  }
  
  int nb_matches = 0;
  struct dirent * entry;

  /* TODO[2] : parcourir les entrées du répertoire */
  /* TODO[2] : pour chaque entrée, tester si son nom de base coïncide
   * avec celui cherché */
  /* TODO[3] : si l'entrée considérée est un répertoire, y poursuivre récursivement 
   * la recherche */
   while((entry=readdir(dir))){
	   if((entry->d_type==DT_DIR) & (strcmp(entry->d_name, ".\0")!=0) & (strcmp(entry->d_name, "..\0")!=0)){
		   char * path2=concat_strings(path, "/\0", entry->d_name);
		   if(path2==NULL) return -1;
		   int nb2=process_dir(path2, target_name);
		   free(path2);
		   if(nb2==-1) return -1;//erreur
		   nb_matches+=nb2;
	   }
	   if(strcmp(target_name, entry->d_name)==0){
		   printf("%s\n", path);
		   nb_matches++;
	   }
   }

  closedir(dir);
  return nb_matches;
}



int main(int argc, char ** argv) {
  char *path;
  char *target;
  int nb_matches;

  switch (argc) {
    case 2:
      path = ".";
      target = argv[1];
      break;
    case 3:
      path = argv[1];
      target = argv[2];
      break;
    default:
      dprintf(STDERR_FILENO, "usage: %s path target\n", argv[0]);
      exit(EXIT_FAILURE);
  }

  /* TODO[2] : vérifier que le chemin est valide et désigne un répertoire */
  if(stat(path, &stat_buffer)==-1){
	  printf("erreur stat\n");
	  exit(EXIT_FAILURE);
  }
  if(!S_ISDIR(stat_buffer.st_mode)){
	  printf("erreur stat\n");
	  exit(EXIT_FAILURE);
  }
  
  /* Lancer la recherche */
  nb_matches = process_dir(path, target);
  printf("%d\n", nb_matches);

  /* TODO[2] : terminer avec EXIT_SUCCESS ou EXIT_FAILURE selon les cas */
  if(nb_matches<1) exit(EXIT_FAILURE);
  exit(EXIT_SUCCESS);
}

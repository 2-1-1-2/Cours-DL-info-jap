#include <unistd.h>
#include <stdlib.h>
#include <fcntl.h>
#include <string.h>
#include <stdio.h>
#include <sys/wait.h>
#include "mppsh-exec.h"

#define NB_BUILTINS 4
char *builtins [NB_BUILTINS] = {
  "cd",
  "echo",
  "exit",
  "jobs"
};


/* recouvre le processus courant avec argv après redirection de l'entrée
 * et de la sortie standard */
void execute(char **argv, char *ref_in, char *ref_out, int flag) {
  /* TODO : redirection de l'entrée si ref_in non nul */
  if(ref_in!=NULL){
    int fd1=open(ref_in, O_RDONLY);
    if(fd1==-1) printf("erreur ref_in\n");
    dup2(fd1, 0);
  }

  /* TODO : redirection de la sortie si ref_out non nul */
  if(ref_out!=NULL){
    int fd2;
    switch(flag){
      case O_TRUNC:
        fd2=open(ref_out, O_WRONLY|O_TRUNC);
        break;
      case O_APPEND:
        fd2=open(ref_out, O_WRONLY|O_APPEND);
        break;
    }
    if(fd2==-1) printf("erreur ref_out\n");
    dup2(fd2, 1);
  }

  /* TODO : recouvrement */
  execvp(argv[0], argv);
}

/* lance l'exécution d'une commande externe, avec redirections éventuellement,
 * à l'avant-plan si bg==0, à l'arrière-plan sinon */
int exec_external(char **argv, char *in_out[2], int flag, int bg) {
  /* TODO[1] : gérer uniquement le cas bg = 0 */
  if(bg!=0){
    if(fork()==0) execute(argv, in_out[0], in_out[1], flag);
  }
  else{
    if(fork()==0) execute(argv, in_out[0], in_out[1], flag);
    else wait(NULL);
  }
  return 0;
}


int is_builtin(char *cmd) {
  for (int i = 0 ; i < NB_BUILTINS; i++) {
    if (strcmp(builtins[i], cmd) == 0)
      return 1;
  }
  return 0;
}

/* gère l'exécution des commandes internes, éventuellement avec
 * redirection, toujours à l'avant-plan */
int exec_builtin(int argc, char **argv, char *in_out[2], int flag) {

  /* TODO : à compléter */

  return 0;
}

/* examen des jobs au début de chaque tour de boucle */
void examine_bg () {

  /* TODO : à compléter */

}

//TP9 --> pas testé :)))
void execute_compose(char** argv1, char** argv2, char* ref_in, char* ref_out, int flag){
  int fd[2];
  if(pipe(fd)==-1){
    printf("error pipe\n");
    exit(1);
  }
  switch(fork()){
    case 0://ecrire sur fd1
      close(fd[0]);
      execute(argv1, ref_in, fd[1], flag);
      break;
    default://lire sur fd0
      close(fd[1]);
      execute(argv2, fd[0], ref_out, flag);
  }
}

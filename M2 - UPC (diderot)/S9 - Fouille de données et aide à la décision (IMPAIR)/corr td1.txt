# coding=utf-8
import math
from random import random


def average(lst):
  """ Computes the average of the values in a list of integers.

  Args:
      lst: a list of integers.

  Returns:
      A float that represents the average of the values in lst.
  """
  s = 0.0
  num = 0
  for i in lst:
    s += i
    num += 1
  return s / num


def median(lst):
  """ Computes the median of the values in a list of integers.

  Args:
      lst: a list of integers.

  Returns:
      A float that represents the median of the values in lst.
  """
  s = sorted(lst)
  l = len(lst)
  if l % 2 == 1:
    return s[l // 2]
  return (s[l // 2 - 1] + s[l // 2]) / 2

def bad_sample2(size, avg, med):
  half = ((size + 1) // 2)
  l = [med] * half
  x = avg*size - med*half
  l.extend([x / (size - half)] * (size - half))
  return l
    
def bad_sample(size, delta):
  return bad_sample2(size, delta, 0)

def occurrences(lst):
  """ Computes the occurrences of the values in a list of integers.

  Args:
      lst: a list of integers.

  Returns:
      A dictionary where each key is a value in lst and each value is the number
      of times the key appears in lst.
  """
  d = {}
  for x in lst:
    if x in d:
      d[x] += 1
    else:
      d[x] = 1
  return d


def unique(lst):
  """ Returns the unique values of a list of integers.

  Args:
      lst: a list of integers.

  Returns:
      A list containing the unique values in lst.
  """
  d = {}
  u = []
  for x in lst:
    if x not in d:
      d[x] = 0
      u.append(x)
  return u


def squares(lst):
  """ Squares the values of a list of integers.

  Args:
      lst: a list of integers.

  Returns:
      A list containing the squared elements of lst, in the same order.
  """
  return [x * x for x in lst]


def stddev(lst):
  """ Returns the standard deviation of a list of integers.

  Args:
      lst: a list of integers.

  Returns:
      A float representing the empirical standard deviation of elements in lst.
  """
  avg = average(lst)
  return math.sqrt(average(squares(lst)) - avg * avg)


def quicksort(lst):
  """ Returns a sorted version of lst.

  Args:
      lst: a list of integers.

  Returns:
      A list of the integers from lst, in increasing order.
  """
  if len(lst) < 2:
    return lst
  pivot = lst[0]
  # On utilise les comprehensions de liste, les slices, et l'operateur +. Cf doc online.
  return quicksort([x for x in lst[1:] if x <= pivot]) + [pivot] + quicksort(
      [x for x in lst[1:] if x > pivot])


def uniform(n):
  """ Returns a discrete uniform variable between 0 and n-1, i.e., it returns

  every number between 0 and n-1 with the same probability.
  Args:
      n: a positive integer
  """
  return int(random() * n)


def exam_success(n, p):
  """ Returns the number of exams passed by a student.

  Args:
      n: number of independent exams the students sits for.
      p: probability of passing one exam.

  Returns:
      An integer representing the total number of exams passed by the
      student.
  """
  num_passed = 0
  for x in range(n):
    if random() < p:
      num_passed += 1
  return num_passed


def monty_hall(change):
  """ Simulates a Monty Hall game: a candidate is asked to choose between three

  doors with only one of them containing a reward. Once the candidate has chosen
  a door, the anchorman opens one of the other doors that does not contain the
  reward. The candidate may now change doors for the remaining one. This
  function
  returns 1 if the candidate found the reward and 0 otherwise.
  Args:
      change: a boolean representing whether the candidate changes doors.

  Returns:
      1 if the candidate found the reward at the end of the game, 0 otherwise.
  """
  doors = [0, 0, 0
          ]  # On va mettre '1' a la position de la voiture (qui est 0, 1 ou 2)
  doors[uniform(3)] = 1
  # Disons que le candidat choisit au hasard aussi.
  choice = uniform(3)
  # L'animateur doit alors montrer un slot vide, qui n'est pas le slot choisi.
  # On dresse la liste de ces slot, et on en prend un au hasard.
  possible_slots_shown = []
  for slot in range(3):
    if doors[slot] == 0 and slot != choice:
      possible_slots_shown.append(slot)
  # L'animateur choisit un slot (au hasard parmi les possibles) et le montre.
  slot_shown = possible_slots_shown[uniform(len(possible_slots_shown))]
  # On simule le 'changement', si le candidat avait decide de changer:
  # il choisira le slot restant.
  # Trick: On utilise le fait que la somme des slots fait 0+1+2 = 3.
  if change:
    choice = 3 - choice - slot_shown
  # On a le choix final! On renvoie 1 si il y a une voiture derriere.
  return doors[choice]


def monty_hall_simulation(n):
  """ Simulates n Monty Hall games with the candidate changing doors and n Monty

  Hall games with the candidate not changing doors. Returns the frequency with
  which the candidate found the reward in each case.
  Args:
      n: the number of games to simulate.

  Returns:
      A tuple (p1, p2) where p1 (resp. p2) is the frequency with which the
      candidate found the reward when always (resp. never) changing doors.
  """
  out = []  # La paire renvoyÃ©e en sortie
  for change in [True, False]:
    num_wins = 0.0
    for _ in range(n):
      num_wins += monty_hall(change)
    out.append(num_wins / n)
  return out[0], out[1]
